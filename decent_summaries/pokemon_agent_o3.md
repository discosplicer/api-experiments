The program is a self-contained middleware layer that attaches a language-model–driven SimpleAgent to a running Game Boy ROM through the PyBoy emulator. One live frame after another is exposed to three parallel chat sessions—Anthropic/Claude, Google Vertex/Gemini and OpenAI—while any joy-pad commands produced by the LLM are injected back into the emulator. With the exception of two hard-coded constants (BASE_IMAGE_SIZE = 160 × 144 and MAX_TOKENS_OPENAI = 50 000) every credential or hyper-parameter is read from config.py; NumPy, Pillow, PyBoy and the three vendor SDKs are imported at start-up.

Core data structures  
• LocationCollisionMap is a sparse, auto-growing NumPy grid whose cells encode –1 unknown, 0 wall, 1 walkable, 2 NPC/sprite and 3 the player. Each video frame the 10 × 9 collision mask from Game Boy RAM is merged, border tiles are padded, the former player marker is cleared, a new one written, and a breadth-first distance field up to depth 99 regenerated. The class can 1) emit the map as a machine-parsable string, 2) render a compact ASCII image for humans and 3) back-walk the gradient to yield the shortest D-pad path to any on-screen tile. Every revision is appended to mapping_log.txt.  
• TextDisplay is a 20-line scrolling buffer. Every line is mirrored both to the Python logger and to text_output.txt so that developers can follow the agent’s own reasoning and the streamed chain-of-thought of each LLM in real time.

Agent initialisation and persistent state  
SimpleAgent.__init__ boots PyBoy (optionally from a save-state), instantiates whichever LLM providers are requested and allocates a large, mutable state bundle: per-provider chat histories (main and “navigator”), deques of recent coordinates, caches of LocationCollisionMap objects, exploration bit-maps, label archives, visited / fully mapped area sets, step and checkpoint counters, and the TextDisplay. When “full-map” support is enabled every new frame is folded into the cached map and its ASCII snapshot stored for later prompts.

Visual tools  
get_screenshot_base64() captures the native 160 × 144 framebuffer, can upscale 4×, overlays a red tile grid (axes anchored at 4,4), sprite markers, collision / exploration shading and arbitrary per-tile annotations such as “IMPASSABLE” or “CHECK HERE”. The annotated PNG is saved in /tmp and returned as a base-64 data URL (suppressed while the avatar is in combat).  
update_and_get_full_collision_map() downsamples the live collision mask, refreshes or creates the LocationCollisionMap for the current zone, optionally tints it by exploration status and returns its ASCII view. get_all_location_labels() yields every ((col,row), label) pair inside the current area.

Archiving and context compression  
save_location_archive() pickles seventeen-plus structures—chat histories, maps, trackers, counters, etc.—and load_location_archive() restores them, tolerating schema drift and discarding half-written tool_use stubs. strip_text_map_and_images_from_history() deletes every screenshot object except the two freshest and collapses older [TEXT_MAP] blocks to a single placeholder; OpenAI’s special multipart format is handled explicitly.

Tool interface  
press_buttons(button_list, wait, tool_id) logs the action, calls emulator.press_buttons(), rereads memory info and coordinates, refreshes caches and exploration masks, then assembles a structured tool_result. For OpenAI the result is plain text; for Claude and Gemini it can embed a screenshot, a [TEXT_MAP] block, step / checkpoint counters and combat flags so that all three providers remain perfectly synchronised.  
process_tool_call() reconciles provider-specific wrappers (Claude .content/.input, Gemini .args, OpenAI .arguments JSON) and dispatches to eight handlers: press_buttons; navigate_to; navigate_to_offscreen_coordinate (via generate_buttons_to_coord or a secondary “distant navigator” LLM whose streamed reasoning is sent to TextDisplay); bookmark_location_or_overwrite_label; mark_checkpoint; navigation_assistance; detailed_navigator (toggles verbose navigation mode); and a default handler. Anthropic token consumption is measured; Gemini and OpenAI include retry loops for transient HTTP 500 or safety failures. If a provider reply contains no tool_calls a queued follow-up user message—“Can you please continue playing the game?”—nudges the assistant to resume play.

Main control loop  
run() parks the Python thread until PyBoy is ready, optionally loads a save-state and then iterates for num_steps while updating absolute_step_count. On first entry into any new area it prints “New Location reached!” to TextDisplay, records (location, absolute_step_count) in location_milestones, adds the area to all_visited_locations and updates last_coords.

Navigator mode  
If self.detailed_navigator_mode is active and the avatar is not in combat, TextDisplay prints “NAVIGATOR MODE”, takes a fresh screenshot, rebuilds the [TEXT_MAP], prunes older media from navigator_message_history and appends a new user message with the map, screenshot and a reminder to turn back when reaching any tile in no_navigate_here. Outside navigator mode message_history is used; strip_text_map_and_images_from_history() limits media to the two newest copies. For Claude, the newest and third-newest user messages are flagged {"cache_control":{"type":"ephemeral"}} to reduce billing.

Provider-specific prompt / response flow  
• Claude selects either SYSTEM_PROMPT or FULL_NAVIGATOR_PROMPT, supplies an explicit tools list, logs usage, extracts tool_use blocks and streams the remaining reasoning into TextDisplay.  
• Gemini converts the history into Vertex-AI “parts”, wraps them in GenerateContentConfig with system_instruction and tools, retries up to two times on HTTP 500 and returns (assistant_text, tool_calls, assistant_content, malformed flag).  
• OpenAI first re-synchronises if the last message was a function_call_output, optionally attaching the latest screenshot, [TEXT_MAP], recent labels, location history, checkpoint list, steps_since_location_shift and an in-combat flag. It then calls openai_client.responses.create() with MAX_TOKENS_OPENAI and the tool schema, retrying on BadRequestError. Immediately afterwards every earlier screenshot object is replaced by the literal string “Screenshot omitted in history for brevity” and any JSON-embedded screenshots inside function_call_output strings are scrubbed to cap context growth. Token usage is logged.

After a response arrives the active history (navigator_message_history or message_history) appends assistant_content, then each tool_call is executed via process_tool_call() and its structured result injected back as a “user” message. For OpenAI the result is wrapped in {"type":"function_call_output", …}. Navigator histories are trimmed when they exceed self.max_history; the cut ensures no orphaned tool_results survive. A second pass removes any leading OpenAI function_call_output that lacks a matching call.

Automatic summarisation  
If message_history becomes too long or cumulative OpenAI usage passes 170 000 tokens, agentic_summary() launches a three-stage meta-summary pipeline and replaces the entire history by one user entry that starts “CONVERSATION HISTORY SUMMARY …”. A subsequent history reset is prepared for each provider: Claude gets a multipart user message (summary text, current screenshot, reminder); OpenAI receives the equivalent two-part {"type":"input_text", …}, {"type":"input_image", …} message.

Self-regulation counters  
absolute_step_count, steps_since_checkpoint, steps_since_label_reset and steps_since_location_shift are updated every tick. detailed_navigator_mode auto-activates after 300 stagnant steps; after 50 steps without a checkpoint location_tracker is initialised. Entering a new area heuristically labels the spawn tile “Entrance to <area> (Approximate)”, resets counters and disables detailed_navigator_mode unless the new area is exempt. Non-approximate labels are pruned after 200 steps in Claude sessions and 1000 steps in Gemini or OpenAI sessions. Every save_every ticks—or on orderly shutdown—the emulator state, location archive and location_milestones.txt are flushed. KeyboardInterrupt triggers a clean exit; any other exception is re-raised after logging; emulator.stop() is always called if PyBoy owns the main thread.

Auxiliary helper  
navigation_assistance(goal) composes a blob of the current ASCII map plus all labels and the requested goal, then invokes prompt_text_reply() with NAVIGATION_PROMPT (no history, no screenshot). The advice is echoed to TextDisplay. prompt_text_reply() is provider-agnostic, may prepend history and/or a screenshot, applies Claude’s ephemeral marking rules and retries on transient failures.

Throughout its lifetime the agent streams every step of its own reasoning and each LLM’s reasoning into TextDisplay, reconciles Anthropic/Gemini/OpenAI JSON formats and button schemas, monitors token budgets, saves checkpoints, updates exploration masks, keeps all chat histories and on-disk archives in exact step with the emulator’s state and guarantees eventual shutdown via stop(), which sets self.running = False and calls emulator.stop().

Execution entry point  
Under the __main__ guard the script finds pokemon.gb relative to itself, instantiates SimpleAgent with that ROM and runs agent.run(num_steps = 10) inside a try/except block that logs completion count and handles KeyboardInterrupt gracefully; agent.stop() is always called in finally to ensure a tidy shutdown.