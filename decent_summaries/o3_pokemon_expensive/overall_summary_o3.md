The repository contains a coordinated set of Python modules that allow an automated agent, backed by a large-language model, to play Pokémon Red inside the PyBoy Game Boy emulator.  Taken together, the files deliver low-level control of the emulator, detailed inspection of Game Boy RAM, long-running conversational history management, and a library of system, navigation, and meta prompts that govern how the model reasons and when it may invoke each tool.

emulator.py runs a PyBoy instance on its own thread.  All cross-thread actions—button presses and releases, delays, save- or load-state requests, and shutdown signals—enter a priority-ordered command queue protected by a PriorityLock, and every accepted command advances the game exactly one frame.  The module also exposes utility calls for screenshots, raw memory reads, collision-map construction, sprite detection, movement sanity checks, and an A* path-finder that can return either a full move sequence or a nearest-tile fallback.

memory_reader.py offers structured access to in-game memory.  It defines IntEnum and IntFlag classes for status conditions, tilesets, species, moves, badges, and map identifiers, then introduces a PokémonData dataclass that mirrors the party layout in RAM and gives direct accessors for HP, level, status, moves, and experience.  The encompassing PokémonRedReader wraps a PyBoy memory view and can fetch player and rival names, money, badges, party information, bag contents, elapsed game time, on-screen coordinates, current map and tileset, warp-tile data, dialog text, and Pokédex counts, translating the game’s proprietary character encoding into ASCII for downstream use.

prompts.py centralizes every prompt string the agent may send to the model.  It includes exploration prompts, step-by-step navigation instructions, meta-knowledge extraction and cleanup prompts, and a large SYSTEM prompt that embeds rules, tool-call syntax, and a section labeled “BIG HINTS.”  The file assigns reliability tiers to evidence and spells out the exact circumstances under which each tool—press_buttons, navigate_to, bookmark_location_or_overwrite_label, mark_checkpoint, detailed_navigator, and others—may be invoked.  Several legacy summary prompts are retained for backward compatibility.

simple_agent.py is the orchestrator.  It incrementally builds an ASCII collision map that merges walkable tiles, walls, sprite positions, and the player’s coordinates, then uses this map for path-finding and automatic button-sequence generation.  The agent logs on-screen dialog, captures annotated Base-64 screenshots, and periodically pickles its entire state to disk.  All tool calls (press_buttons, navigate_to, etc.) are wrapped, logged, and returned in a format that matches the active LLM back end (OpenAI, Claude, or Gemini).  The module streams conversation with the model, extracts function calls, executes them, trims history, triggers auto-summarization when token budgets tighten, and switches to a detailed navigator mode after extended inactivity.  It also tracks steps taken, checkpoints, milestones, and location labels, resetting obsolete labels and shutting down cleanly when requested.

The overall execution loop is:

1. Start the emulator thread and wait for readiness.  
2. In each cycle, read game RAM, update the collision map and conversational histories, dispatch the combined prompt to the model, parse any returned tool calls, execute them within the emulator, and record results.  
3. Background services continuously manage screenshots, periodic summarization, auto-saving, and graceful shutdown.

tool_definitions.py constructs a master list of six active tools—press_buttons, navigate_to, navigate_to_offscreen_coordinate, bookmark_location_or_overwrite_label, mark_checkpoint, and detailed_navigator—each paired with a natural-language description and a JSON Schema that defines its arguments.  A seventh tool, navigation_assistance, is left inert inside a string placeholder for future activation.  Helper functions convert this master list into provider-specific dictionaries named GOOGLE_TOOLS and OPENAI_TOOLS.

Slimmed “navigator-only” variants eliminate detailed_navigator and mark_checkpoint, and an even more constrained DISTANT_NAVIGATOR_BUTTONS set limits button presses to the four cardinal directions.  Conversion helpers for these reduced tool sets are also included.

utils.py supplies provider-agnostic helper routines shared across the codebase.  convert_anthropic_message_history_to_google_format transforms an Anthropic-style chat history into google.genai Content objects, preserving roles, text, images, tool invocations, and results.  extract_tool_calls_from_gemini separates Gemini responses into free text and function calls, repairs calls found inside Markdown code blocks, and flags any malformed recoveries.

Two additional converters reshape the internal tool specifications themselves: one creates Google-compatible copies by performing a shallow copy and renaming input_schema to parameters, while the other produces OpenAI-compatible definitions via a deep copy that also inserts an explanation_of_action field and tags the object as a function.  These converters rely only on the copy and typing modules and include inline notes that document Gemini-specific quirks such as the required ordering of image parts in a message.