File simple_agent.py Summarized: 

The program begins by importing the standard Python library together with Pillow, NumPy, the SDKs for Anthropic, Google Gemini and OpenAI, several project-specific configuration files, and various internal helpers.  Immediately afterward it configures application-wide logging, defines constants that describe the on-screen image dimensions, and enforces a hard cap of 50 000 tokens for any individual outbound OpenAI request.

A central component is the LocationCollisionMap class.  It maintains a dynamically growing two-dimensional grid whose tiles are tagged passable, impassable, sprite, player or unknown.  When the player moves, update_map merges the most recent 9 × 10 collision window and sprite data into the grid and automatically expands the map if the player crosses the current boundary.  To support path-finding, compute_effective_distance_to_tiles performs a breadth-first search from the player position and caches the resulting distance map.  generate_buttons_to_coord back-tracks through this cache to produce the exact D-pad button sequence required to reach any reachable coordinate.  Two rendering helpers exist: make_ascii_segment, which produces a verbose, LLM-oriented slice, and to_ascii, which outputs a concise human-readable representation that is written to mapping_log.txt.

TextDisplay holds a rolling buffer of on-screen text and continuously writes the newest slice to text_output.txt so that external observers can monitor dialogue in real time.

SimpleAgent.__init__ constructs the agent.  It can spawn the game emulator on the current or on a separate thread, optionally loads a saved emulator state, and establishes a connection to Anthropic, Gemini or OpenAI according to configuration.  During creation the agent seeds separate conversation and navigation histories together with numerous trackers, visitation logs, counters and control flags.

To facilitate visual debugging, get_screenshot_base64 captures a screenshot, rescales it, overlays a red alignment grid, annotates the surrounding 9 × 10 tiles, labels the coordinates (using larger fonts when the active model is Gemini), saves a debug PNG to disk and returns the image encoded as Base-64.

Long-term state persistence is handled by save_location_archive, which pickles labels, histories, trackers, counters, maps and related agent state, and by load_location_archive, which restores that state, tolerates older pickle formats, strips unfinished tool_use blocks and warns if no archive exists.

strip_text_map_and_images_from_history is a static helper that deletes embedded images from message history entries and replaces large [TEXT_MAP] blocks with placeholders.  It understands both plain and OpenAI function-call schemas and is used to reduce token consumption.

update_and_get_full_collision_map fetches the latest collision grid from the emulator, builds or refreshes the LocationCollisionMap corresponding to the current RAM-reported “location,” and returns an ASCII rendering that may be colour-coded.  get_all_location_labels supplies every stored (column, row, label) triple for a given location name, using case-insensitive matching.

The primary tool available to an LLM is press_buttons.  The method logs the requested button list via TextDisplay, executes the sequence in the emulator, captures memory_info and records the resulting collision map.  It updates location_history and a two-dimensional location_tracker to mark the visited tile.  The returned tool_result is minimal when OpenAI is the backend; for Gemini or Anthropic, and when navigator mode is active, the structure can also include a screenshot, the full collision map, memory contents, labels, the recent movement path, checkpoints, the current step count and a combat flag.

process_tool_call identifies the active LLM, parses incoming tool invocations, logs them and—when OpenAI is being used—echoes the caller’s action text to TextDisplay.  The Dispatcher’s corresponding handler extracts the “buttons” list (and optional “wait” value) and forwards the call to press_buttons.

navigate_to translates a global (column, row) target into window coordinates, determines a path, presses each required direction, records the last and next coordinates, then captures a screenshot, memory_info and the collision map.  It updates histories and trackers and produces a tool_result that is plain text for OpenAI but richer for Claude or Gemini.  navigate_to_offscreen_coordinate first checks reachability using the full collision map and raises an error if the destination is unreachable.  If the DIRECT_NAVIGATION flag is set, it auto-generates the button sequence; otherwise it crafts a prompt containing the map and rules, sends it to the configured LLM, retries on failure, parses the returned tool_use block and finally passes the buttons to press_buttons.

Utility commands include bookmark_location_or_overwrite_label, which stores or updates a (location, row, col) label; mark_checkpoint, which resets step counters, deactivates the location_tracker and records a checkpoint; and detailed_navigator, which turns on detailed navigator mode and seeds separate navigator histories.  Any unrecognized tool name is merely logged and yields an error-type tool_result.

run() may execute on a separate thread when the emulator must stay on the main thread; in that arrangement the call immediately returns the current step count.  Before entering its main loop the agent waits for PyBoy readiness, optionally reloads a saved state, and logs “Starting agent loop.”

During each iteration the agent reads the current location and tile coordinates from RAM.  First-time visits are logged, milestone-tagged and added to the all_visited_locations set.  If detailed_navigator_mode is active and the player is not in combat, the agent appends a Base-64 screenshot and a fresh full collision map to navigator_message_history and instructs the navigator to avoid forbidden regions; otherwise it updates the regular message_history.  In both histories large [TEXT_MAP] blocks and obsolete images are stripped, and newly added images are marked ephemeral to conserve tokens.

Three model-specific branches handle LLM interaction.  For Claude, the code calls anthropic_client.messages.create with either FULL_NAVIGATOR_PROMPT or SYSTEM_PROMPT and echoes token usage together with any tool_use blocks to TextDisplay.  For Gemini it converts history to Google-formatted messages, retries on HTTP-500 errors, extracts free-form tool calls via extract_tool_calls_from_gemini and shows the returned text in an overlay.  For OpenAI it builds or extends openai_(navigator_)message_history, potentially injecting memory_info, labels, paths, checkpoints, counters, screenshots and the collision map, then streams responses.create; any images returned by the model are discarded while reasoning text, tool calls and plain text are parsed from the stream.

All detected tool_use blocks are appended to history, dispatched through process_tool_call and their results re-inserted (plus function_call_output for OpenAI).  If a Gemini or Claude tool call is malformed, a warning line is inserted into the tool_results list.

History size is actively managed.  Navigator histories are trimmed to max_history and orphaned tool_results or function_call_output entries are removed.  If the combined regular message_history exceeds max_history, or if OpenAI token usage surpasses 170 000, the agent calls agentic_summary() to condense context.  When an LLM reply contains no tool calls, the agent injects a “please continue playing” user message to prompt further action.

Step-tracking counters increment every loop.  After 300 steps without a location change detailed_navigator_mode is automatically enabled; after 50 steps without a checkpoint the location_tracker activates.  Upon a location change the agent may label the prior tile as an entrance, resets shift and label timers and turns off detailed_navigator_mode.  Every 200 steps when using Claude, or 1000 steps otherwise, non-“approximate” labels in the current location are cleared unless a label reset has occurred recently.

Progress, checkpoints and milestones are logged, displayed and periodically auto-saved together with the location archives.  Clean shutdown handles KeyboardInterrupt and other exceptions gracefully.

navigation_assistance() builds a prompt that includes the current collision map and labels, calls prompt_text_reply() and displays the navigation advice in TextDisplay.  prompt_text_reply() can include optional history and screenshots, formats the request for Anthropic, Gemini or OpenAI, sends it and returns the combined textual response.

agentic_summary() gathers RAM information, checkpoints, labels, maps and screenshots, performs three successive prompt_text_reply() passes (facts, cleanup, summary), logs the outputs, writes a summary file, captures a fresh screenshot and replaces the full message_history with the condensed version.  It then creates an initial openai_message_history entry and an anthropic_message_history entry that both embed the condensed summary together with the Base-64 screenshot so that play can resume with minimal context.

The stop() method halts the agent loop by setting self.running to False and calling emulator.stop().  Finally, the __main__ stanza resolves the Pokémon ROM path, instantiates a SimpleAgent, runs it for ten steps, logs completion, handles KeyboardInterrupt cleanly and always invokes agent.stop() before exiting.