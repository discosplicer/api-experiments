File memory_reader.py Summarized: 

The module begins by declaring several enumeration classes that translate raw numeric values from Pokémon Red’s memory into meaningful labels.  StatusCondition is implemented as an IntFlag whose bit mask represents sleep (bits 0–2), poison, burn, freeze, and paralysis; it also provides convenience methods is_asleep() and get_status_name().  Tileset, PokémonType, Pokémon, Move, and MapLocation appear as IntEnum subclasses that respectively map tileset IDs 0x00–0x17, elemental type IDs 0x00–0x1A, the 151 first-generation species (with “MissingNo.” placeholders), first-generation move IDs 0x01–0xA5, and every overworld or interior map ID in Kanto.  Badge is another IntFlag whose eight single-bit values correspond to the Boulder, Cascade, Thunder, Rainbow, Soul, Marsh, Volcano, and Earth badges.

A dataclass called PokémonData mirrors the structure of an individual party member as it exists in memory.  Each instance stores the species, current and maximum HP, level, status mask, primary and secondary types, four moves together with their remaining PP, the trainer ID, total experience, and an optional nickname.  The class also exposes properties that forward to StatusCondition: is_asleep reports whether the sleep bits are set, while status_name returns a human-readable description of any condition currently affecting the Pokémon.

All higher-level access to game state is concentrated in PokémonRedReader, whose constructor receives a PyBoy memory view.  At its core, the class offers get_warps(), which returns the coordinates of every warp tile on the active map, read_in_combat() to test if a battle is underway, and read_money(), which converts the three Binary-Coded Decimal bytes used by the game into an integer amount of Pokédollars.  Text copied from VRAM or SRAM is passed through a private _convert_text routine that translates Pokémon Red’s proprietary encoding—letters, digits, punctuation, control codes such as newline and “POKé”, the special “é” character, and all bytes from E0 through FF—into standard ASCII, with a hex escape fallback for any unknown value.  A secondary helper finalizes the mapping table by covering the high-byte range and adding the digits 0–9.

Reader methods target specific memory regions.  read_player_name() decodes the trainer’s name from addresses 0xD158–0xD162, while read_rival_name() does the same for the rival’s name at 0xD34A–0xD350.  read_badges() inspects byte 0xD356 and returns a list of badge names whose bits are set.  read_party_size() simply returns the count stored at 0xD163, and read_party_pokémon() iterates over the subsequent structures to build up to six PokémonData instances containing species, HP, level, status, types, moves with PP, trainer ID, and experience.  read_game_time() extracts the hour, minute, and second counters from 0xDA40–0xDA44.

Several smaller helpers give additional context: read_location() returns the current map ID from 0xD35E, read_tileset() reveals which tileset is in use at 0xD367, and read_coordinates() fetches the player’s X and Y positions from 0xD362 and 0xD361.  read_coins() sums the Game Corner coin balance stored at 0xD5A4–0xD5A5.  Inventory support comprises read_item_count() at 0xD31D and read_items(), which walks through the item list, decodes standard items and the TM/HM ID ranges, and returns (name, quantity) pairs.

For user interface text, read_dialog() scans the tile-map buffer at 0xC3A0–0xC507, removes border graphics, runs the raw bytes through _convert_text, and returns whatever dialog is presently on screen, with a special branch that recognises the name-entry menus.  Finally, read_pokedex_caught_count() tallies the set bits in 0xD2F7–0xD309 to report how many different Pokémon species have been caught.