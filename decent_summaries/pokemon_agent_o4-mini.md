The exploration agent is implemented as a Python-threaded Autonomous Player for the PyBoy Game Boy emulator, designed to navigate game worlds by fusing real-time collision mapping, in-game text logging and LLM‐driven decision making. It is instantiated via the SimpleAgent class, which on startup computes the path to “pokemon.gb” relative to its script, loads any requested emulator snapshot, configures emulator dimensions and token budgets, and selects among three supported LLM backends—Anthropic Claude, Google Gemini or OpenAI—according to external settings. Once running, SimpleAgent spawns a dedicated thread that waits for PyBoy readiness, initializes its `openai_message_history` with a single user‐role entry combining an `input_text` block (the conversation summary, a “Current game screenshot for reference:” note and a prompt to choose the next action) and an `input_image` block embedding the same screenshot as a data URI, and then enters its main loop for a specified number of steps or until interrupted.

Underpinning navigation is LocationCollisionMap, which maintains both a growing global collision grid and a fixed 9×10 local viewport around the player. Each time the emulator emits raw collision data, update_map() merges it into the master grid and recomputes a breadth‐first‐search distance field from the player’s current tile. When the agent must move, generate_buttons_to_coord() backtracks along this field to yield the shortest sequence of button presses. For human or offline inspection, to_ascii() serializes the full grid and legend into machine- and human-readable ASCII and appends it to a mapping_log.txt file.

TextDisplay captures and logs all in-game dialogue: it maintains a rolling buffer of recent lines, prints each new line to the console, and appends it to a persistent text_output.txt. SimpleAgent itself tracks its evolving state—two message histories (general and detailed navigator mode), visited location identifiers, archives of signpost and NPC dialogue labels, planned navigation goals, milestone checkpoints and emulator snapshots. It persists these via pickled snapshots in a backward-compatible format, warning if expected files are missing, and can invoke strip_text_map_and_images_from_history() to remove embedded images and `[TEXT_MAP]` tokens in order to conserve LLM context tokens.

When detailed navigator mode is triggered—either after prolonged inactivity (300 steps without changing location) or by explicit request—the agent captures the emulator framebuffer as a PIL image, overlays grid lines, coordinates and tile descriptors, downsamples the collision grid to the local 9×10 view, classifies each tile (e.g. IMPASSABLE, EXPLORED), draws labels, encodes the result in Base64, and saves this debug image. These images and accompanying [TEXT_MAP] sections may then be stripped on subsequent turns to reduce token usage.

Each loop iteration begins by reading the player’s current area and coordinates. Upon entering any new location, the agent logs a “New Location” milestone, archives any approximate entrance label for the previous area, resets location‐shift and label‐reset counters, disables detailed navigator mode if it was active, and issues a checkpoint if more than 50 steps have elapsed since the last. Four counters—absolute_step_count, steps_since_checkpoint, steps_since_label_reset and steps_since_location_shift—are incremented each turn; after 300 steps without moving, detailed navigator mode is enabled and its history reset; after 50 steps from the last checkpoint, location tracking advice is offered; labels are purged after 200 silent steps under Claude or 1,000 under other models.

Before querying the LLM, SimpleAgent prunes or clones the appropriate history: navigator histories drop older entries up to the last tool_result unless a tool_call intervened; OpenAI histories also remove orphaned function_call_output entries. The most recent one or two user messages are marked ephemeral to prevent unnecessary repetition. The assembled prompt, together with tool specifications, is then dispatched: Claude via its SDK (yielding alternating text and tool_use segments), Gemini via Google’s chat format with retry logic for transient errors, or OpenAI via the Chat Completion API with explicit function_call and function_call_output entries. If the assistant returns no tool_call, the agent appends a follow-up user prompt—“Can you please continue playing the game?”—and retries.

All assistant messages and tool_use segments are appended to the history. Detected tool_calls are forwarded to process_tool_call(), which executes commands such as press_buttons, navigate_to (using BFS‐derived routes or LLM guidance), navigate_to_offscreen_coordinate, bookmark_location_or_overwrite_label, mark_checkpoint, navigation_assistance and detailed_navigator. Each action’s result is captured as a structured tool_result record, appended to the OpenAI history if relevant, and reinjected into the general history. Malformed tool calls generate error logs and error‐formatted tool_result entries.

LLM backend integrations track token usage and handle streaming or streaming‐like behavior: Claude calls encode both system and navigator prompts plus tool specs; Gemini calls are parsed for text, tool_calls and malformed flags; OpenAI interactions automatically append fresh emulator state—memory info, collision map ASCII, screenshots—whenever the assistant invokes a function. To summarize accumulated knowledge or forestall unbounded memory growth, agentic_summary() may be triggered automatically when message counts or token usage exceed thresholds or manually invoked. It gathers RAM usage, step counters, map state, checkpoints, labels, prior summaries and screenshots, then runs a three‐stage LLM pipeline—fact extraction, cleanup and summary—writes the final report to file, and replaces the message history with a solitary summary entry.

Progress is logged every step; every save_every iterations SimpleAgent persists emulator snapshots, the location archive and milestone logs. A stop() method is defined to set `self.running` to False and halt the emulator thread gracefully. Under a Python main guard, the script instantiates SimpleAgent with the resolved ROM path and calls `agent.run(num_steps=10)` inside a try block—logging completed steps, catching KeyboardInterrupt to log interruptions, and always invoking `agent.stop()` in a finally block to ensure proper shutdown.